# summary 



---

The id has two part, 1 is current epoch second ( epoch time is the number second from 1970 to today ) second part is auto increase sequence



Let assume the epoch time start today and I want to user for next 50 years .. we need 31 bits for it

And the maximum 1 second can generate.. photo, so we can use 17bits for the auto increase sequence.





The service can generate the key beforehand and store them in the memory, when someone use it, we can provide them quickly. In the table, we just need store the max value it already generated, for example the max current is 0, generate 5 id, changed the max to 5 and put those 5 to memory



(we need make sure the service change the max to 5 first the put those 5 id to memory)



We need avoid give the key to multiple services, so we need lock or synchronize the part which give the key to services and remove it to used table



We also can think about re collect the short urtl or Id which is expeired





single point failure



1.

We can use one service just for the id generation or two services to avoid the single point failure. One is for odd number and other is for even number



There will be a loader balance in front of those services, just round robin and deal with the down time



the id will be time + machine id+ increase number



2.

or we can use two service one is id generate service and another is id generate shadow



if the master id is dead, keepalived will know, and all request will go to the shadow master ( user keepalived) master service and shadow service have same virtual ip, so client don`t know the request transfer





disadvantage of this way is two machine may have different clock at the same second the ids generated by the two machine may have different epoch time



when from one second to another second the increase number will back to 0. we can find the number of 0 is more than other number


















