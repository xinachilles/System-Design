# RabbitMQ tutorial - Publish/Subscribe — RabbitMQ

Created: 2020-12-24 18:08:03 -0600

Modified: 2020-12-24 18:08:04 -0600

---

Clipped from : <https://www.rabbitmq.com/tutorials/tutorial-three-java.html>

![bRabbitMC) Publish/ Subscribe (using the Java Client) Features Get Started Prerequisites Support Community Docs Blog previous tutorial we created a work queue. The In the assumption behind a work queue is that each task is delivered to exactly one worker. In this part we'll do something completely different we'll deliver a message to multiple consumers. This pattern is known as "publish/subscribe". To illustrate the pattern, we're going to build a simple logging system. It will consist of two programs the first will emit log messages and the second will receive and print them. In our logging system every running copy of the receiver program will get the messages. That way we'll be able to run one receiver and direct the logs to disk: and at the same time we'll be able to run another receiver and see the logs on the screen. This tutorial assumes RabbitMQ is installed and running on local host the standard port (O) In case you use a different host, port or credentials, connections settings would require adjusting. Where to get help If you're having trouble going through this tutorial you can contact us through the mailing list or RabbitMQ community Slack. Essentially, published log messages are going to be broadcast to all the receivers. Exchanges In previous parts of the tutorial we sent and received messages to and from a queue. Now it's time to introduce the full messaging model in Rabbit. Let's quickly go over what we covered in the previous tutorials: A producer is a user application that sends messages. A queue is a buffer that stores messages. A consumeris a user application that receives messages. The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. Actually, quite often the producer doesnt even know if a message will be delivered to any queue at all. Instead, the producer can only send messages to an exchange An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives. Should it be appended to a particular queue? Should it be appended to many queues? Or should it get discarded. The rules for that are defined by the exchange type. There are a few exchange types available: and the fanout. Let's create an exchange of this type, and call it fan out We'll focus on the last one channel . exchangeDec1are ( " Logs" " fanout ; The fanout exchange is very simple. As you can probably guess from the name, it just broadcasts all the messages it receives to all the queues it knows. And that's exactly what we need for our logger. Listing exchanges To list the exchanges on the server you can run the ever useful sudo rabbitmgctl list exchanges In this list there will be some exchanges and the default (unnamed) exchange. These are created by default, but it is unlikely you'll need to use them at the moment. Nameless exchange In previous parts of the tutorial we knew nothing about exchanges, but still were able to send messages to queues. That was possible because we were using a default exchange, which we identify by the empty string (O Recall how we published a message before channel .basicpublish ( " "hello" , null, message. getBytes ( ) ) , The first parameter is the name of the exchange. The empty string denotes the default or nameless exchange: messages are routed to the queue with the name specified by , if it exists. routing Key Now, we can publish to our named exchange instead: channel .basicpublish ( "'logs" , Temporary queues null, message . getBytes 0), As you may remember previously we were using queues that had specific names (remember--- rd Being able to name a queue was crucial for us we needed to point the workers to the same queue. Giving a queue a name is important when you want to share the queue between producers and consumers. But that's not the case for our logger. We want to hear about all log messages, not just a subset of them. We're also interested only in currently flowing messages not in the old ones. To solve that we need two things. Firstly, whenever we connect to Rabbit we need a fresh, empty queue. To do this we could create a queue with a random name, or, even better - let the server choose a random queue name for us. Secondly, once we disconnect the consumer the queue should be automatically deleted. In the Java client, when we supply no parameters to we create a non-durable. exclusive, queueDecIare ( ) autodelete queue with a generated name: String gueueName channel . gueueDec1are . getQueue • flag and other queue properties in the guide on queues. You can learn more about the exclusive At that point contains a random queue name. For example it may look like que u eName JzTY2 OBRgKo-H3mUJ3 OwLg Bindings binding binding We've already created a fanout exchange and a queue. Now we need to tell the exchange to send messages to our queue. That relationship between exchange and a queue is called a binding. channel . queueB1nd (queueName , "logs" From now on the--- xchangewill append messages to our queue. Listing bindings You can list existing bindings using, you guessed it, rabbi tmgctl list bindings Putting it all together amq. gen-RQ6 amq. gen-As8. The producer program. which emits log messages, doesnt look much different from the previous tutorial. The most important change is that we now want to publish messages to our exchange instead of the when sending, but its value is ignored for nameless one. We need to supply a o ut i ngKey fanouC exchanges. Here goes the code for program: EmitLog . ava "Hello World!" 1 The simplest thing that does something python Java Ruby_ C# JavaScriQt Go Elixir Objective-C Swift suing AMQP Work queues 2 Distributing tasks among workers (the competing consumers python Java Ruby_ C# JavaScriQ_t Go Elixir Objec tive-C Swift suing AMOP 3 Publish/ Subscribe Sending messages to many consumers at once python Java Ruby_ p Hp C# JavaScriat Go Elixir Qbjec tive-C Swift suing AMOP Routing 4 Receiving messages selectively python Java Ruby: C# JavaScriQ_t Go Elixir Objective-C Swift suing AMOP Lpics 5 Receiving messages based on a pattern (topics) eython Java Ruby C# JavaScriQt Go E lixir Objective-C Swift suing AMOP 6 RE-C Request/reQly_ pattern example python Java Ruby_ C# JavaScriQ_t Go E lixir suing AMOP Publisher 7 Confirms Reliable publishing with publisher confirms Java C# public class EmitLog private static final String EXCHANGE NAME "logs " , public static void main (String[) argv) throws Exception { Connect IonFactory factory = new Connect1anFactcry ( ) factory . setEost local host") • try (Connection connection factory . newconnection ; connection . createChanne1 ( ) ) Channel channel channel . exchangeDec1are (EXCHANGE NAME, " fanout") ; String message argv. length < 1 ? "'Info: Hellc World! " String. join channel .basicpublish (EXCHANGE NAME, argv) , null , message . getBytes ( " UTE-8")), System. out . printin (" x] Sent + message + (EmitLQgjava source As you see, after establishing the connection we declared the exchange. This step is necessary as publishing to a non-existing exchange is forbidden. The messages will be lost if no queue is bound to the exchange yet, but that's okay for us: if no consumer is listening yet we can safely discard the message. The code for impo t impo t impo t impo t public c cm c cm c cm c cm ReceiveLogs . java . rabbitmg . client . Channel; . rabbitmg . client . Connection; . rabbitmg . client . ConnectionFactory ; . rabbitmq . client . Delivercallback; class ReceiveLcgs private static final String EXCHANGE NAME "logs " , public static void main (String [J argv) throws Exception { Connect IonFactory factory = new Connect10nEactcry ( ) factory . setRost local host") • Connect Ion connection = factory. newcannection ( ) ; connection . createChanne1 ( ) ; Channel channel channel . exchangeDec1are (EXCHANGE NAME, " fanout") • String gueueName channel . gueueDec1are . getQueue ( ) ; channel . queueBind (queueName, EXCHANGE NAME, System. out . printin (" Walting for messages. To exit press CTRL+C") • DeliverCa11back deliverCa11back (consumerTag, delivery) { String message new String (delivery . getBody ( ) , "UTE 8") ; System. out . printin (" x] Received channel . bas 1 cconsume (queueName, true , ReceiveLogsjava source Compile as before and we're done. + message + delivercallback, consumerTag favac ---cp EmitLog. java Rece1veLogs. java If you want to save logs to a file,just open a console and type: fava ---cp SCP ReceiveLcgs > logs from rabbit. log Ifyou wish to see the logs on your screen, spawn a new terminal and run: fava ---cp SCP ReceiveLcgs And of course, to emit logs type: i ava ---cp SCP EmitLog Using you can verify that the code actually creates bindings and queues as we rabbitmqctl list bindings want. With two programs running you should see something like: ReceiveLogs . java s udo rabbi tmgctl list bindings Listing blndings logs exchange logs exchange . done . amg. gen JzTY20BRgKO---HimUJi OwLg amg. gen vsoOPVvyiRIL2WoV3i48Yg queue queue The interpretation of the result is straightforward: data from exchange goes to two queues with server-assigned names. And that's exactly what we intended. To find out how to listen for a subset of messages, let's move on to tutorial 4 Production [Non-ISuitability Disclaimer Please keep in mind that this and other tutorials are. well, tutorials. They demonstrate one new concept at a time and may intentionally oversimplify some things and leave out others. For example topics such as connection management. error handling. connection recovery, concurrency and metric collection are largely omitted for the sake of brevity. Such simplified code should not be considered production ready. Please take a look at the rest of the documentation before going live with your app. We particularly recommend the following guides: Publisher Confirms and Consumer Acknowledgements. Production Checklist and Monitoring. Getting Help and Providing Feedback If you have questions about the contents of this tutorial or any other topic related to RabbitMQ, dont hesitate to ask them on the RabbitMQ mailing list. Help Us Improve the Docs If you'd like to contribute an improvement to the site. its source is available on GitHub. Simply fork the repository and submit a pull request. Thank you! bRabbitMC Copyright 2007-202 o Inc fights Features Get Started Support Community Docs Blog ](../media/Queue-RabbitMQ-tutorial---Publish-Subscribe-—-RabbitMQ-image1.png){width="21.416666666666668in" height="132.75in"}





